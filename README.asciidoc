== Twixt

Twixt is an extensible asset pipeline for use in Clojure web applications.

Twixt includes a very readable HTML exception report page, which displays:

* The entire stack of nested exceptions, top to bottom
* The stack trace for only the root exception
* Demangled namespace and function names for Clojure stack frames (io.aviso.twixt/new-twixt/reify/middleware/fn instead of
  `io.aviso.twixt$new_twixt$reify__954$middleware__959$fn__960.invoke()`).
* The contents of the Ring request map
* All JVM system properties

Twixt draws inspiration from http://tapestry.apache.org[Apache Tapestry] and https://github.com/edgecase/dieter[Dieter].

Twixt currently supports:

* CoffeeScript to JavaScript compilation (using Rhino)
* Jade to HTML compilation (using https://github.com/neuland/jade4j[jade4j])
* Less to CSS compilation (using https://github.com/SomMeri/less4j[less4j])

Twixt is available under the terms of the Apache Sofware License 2.0.

Twixt is downloadable from the https://clojars.org/io.aviso/twixt[Clojars Repository].

=== Usage

By default, Twixt serves resources located on the classpath, in the +META-INF/assets/+ folder.
The contents of this folder is accessible via the URL +/assets/+.

Twixt maps file extensions to MIME types; it then will transform certain MIME types; for example +.coffee+ files are compiled to JavaScript.

[source,clojure]
----
(ns example.app
  (use compojure.core
       ring.adapter.jetty
       [io.aviso.twixt :as t]
       [io.aviso.twixt.exceptions :as te))

;;; Use Compojure to map routes to handlers
(defroutes app ...)

;;; Create a twixt instance and a middleware to handle /asset/ URLs
(def app-handler
  (let [twixt (t/new-twixt {:development-mode true})]
    (->
      app
      (t/wrap-with-twixt twixt)
      (te/wrap-with-exception-reporting twixt))))
    
;;; Use the Ring Jetty adapter to serve your site
(run-jetty app-handler)
----  

The Twixt middleware intercepts requests for +/assets/+ that map to actual files; it returns nil on anything else so that downstream handlers can have their chance.

In development mode, Twixt will write compiled files to the file system (you can configure where if you like). 
On a restart of the application, it will use those cached files if the source files have not changed. Currently, this only applies to Jade and CoffeeScript source files.

=== A question of URLs

At its core, Twixt is a Ring middleware that maps certain URL patterns to matching files on the classpath, and does some transformations along the way.

Currently, the mapping is very straightforward: the path +/assets/css/style.less+ is mapped to resource +META-INF/assets/css/style.less+ and transformed from Less to CSS along the way.

In the future, the mapping will be more complex:

* The URL will include a checksum of the resource's content, e.g., +/assets/32fec9/css/style.less+.
* The URL may reflect the use of GZip compression, e.g., +/assets.gz/33839a/css/style.less+.

Because of this, when referencing assets inside your templates, you must pass paths (relative to +META-INF/assets+) 
through Twixt to get URIs that will work in the browser:

[source,clojure]
----
(defhtml index
  [twixt]
  (html
    (doctype :html5
    [:html
      [:head
        [:title "My Clojure App"]
        (include-css (get-asset-uri twixt "css/style.less"))
        ...
----

=== Configuring Twixt

You may pass any number of option maps to +new-twixt+; they are all recursively merged together.

The default options:

[source,clojure]
----
(def default-options
  {:path-prefix "/assets/"
   :root "META-INF/assets/"
   :content-types (merge mime/default-mime-types {"coffee" "text/coffeescript"
                                                  "less" "text/less"
                                                  "jade" "text/jade"})
   :transformers {"text/coffeescript" cs/coffee-script-compiler-factory
                  "text/less" less/less-compiler-factory
                  "text/jade" jade/jade-compiler-factory}
   :development-mode false
   :cache-enabled false ;; cache is always enabled in development mode
   :cache-folder (System/getProperty "twixt.cache-dir" (System/getProperty "java.io.tmpdir"))})
----

You can override +root+ to change where assets are stored on the classpath, but there is rarely a need to do so. Changing
root may break other libraries that depend on Twixt, such as Twixt's own exception reporting.

You can override +:path-prefix+ to change the root URL for assets; +/+ is an acceptible value.

The +:content-types+ key maps file extensions to MIME types.

The +:transformers+ key maps selected MIME types to a transformer _factory_ for that MIME type.
The transformer factory is passed the fully merged options for the Twixt instance,
and returns a _transformer_. 
The transformer is passed a Streamable, and returns a new Streamable.

Future plugins may provide additional content types and transformers.

Caching is enabled when either +:development-mode+ or +:cache-enabled+ is set to true. 
Running with caching enabled in production is not recommended ... there is no process to remove cached files, and an upgrade of Twixt may change the result of compiling source files, leading to inconsistent results if cached files from prior releases are present.

=== Future Plans

The goal is to achieve at least parity with Apache Tapestry, plus some additional features specific to Clojure. This means:

* E-Tags support
* Content checksums as part of the asset URL
* Far-future expires headers
* ClojureScript compilation
* Automatic GZip support
* Caching of GZipped content
* Separate URL for GZipped content
* JavaScript minimization via https://developers.google.com/closure/compiler/[Google Closure]
* CSS Minification
* Aggregated JavaScript stacks
* Aggregated CSS stacks
* RequireJS support / modules
* Leverage core.async
* Break out the the Less, Jade, and CoffeeScript support into a-la-carte modules

=== Stability

Oh, so very, very alpha. But still useful.

=== A note about feedback

http://tapestryjava.blogspot.com/2013/05/once-more-feedback-please.html[Feedback] is very important to me; I often find
Clojure just a bit frustrating, because if there is an error in your code, it can be a bit of a challenge to track the problem
backwards from the failure to the offending code. Part of this is inherent in functional programming, part of it is related to lazy evaluation,
and part is the trade-off between a typed and untyped language.

In any case, it is very important to me that when thing go wrong, you are provided with a detailed description of the failure.
Twixt has a mechanism for tracking the operations it is attempting, to give you insight into what exactly failed if there
is an error.  For example, (from the test suite):

----
ERROR [                main] io.aviso.twixt.coffee-script An exception has occurred:
ERROR [                main] io.aviso.twixt.coffee-script [  1] - Handling asset request `/assets/invalid-coffeescript.coffee'
ERROR [                main] io.aviso.twixt.coffee-script [  2] - Constructing Streamable for `invalid-coffeescript.coffee'
ERROR [                main] io.aviso.twixt.coffee-script [  3] - Checking file system cache for `META-INF/assets/invalid-coffeescript.coffee'
ERROR [                main] io.aviso.twixt.coffee-script [  4] - Compiling `META-INF/assets/invalid-coffeescript.coffee' to JavaScript
ERROR [                main] io.aviso.twixt.coffee-script META-INF/assets/invalid-coffeescript.coffee:6:1: error: unexpected INDENT
      argument: dep2
^^^^^^
java.lang.RuntimeException: META-INF/assets/invalid-coffeescript.coffee:6:1: error: unexpected INDENT
      argument: dep2
^^^^^^
  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
  at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
  at clojure.lang.Reflector.invokeConstructor(Reflector.java:180)
  at io.aviso.twixt.coffee_script$coffee_script_compiler$fn__806$fn__809.invoke(coffee_script.clj:31)
----

In other words, when there's a failure, Twixt can tell you the steps that led up the failure, which is 90% of solving the problem in the first place.

Twixt's exception wrapper now captures all of this and presents a quite readable exception report page. The exception report
page also does a decent job of de-mangling Java class names to Clojure namespaces and function names. 

=== How does Twixt differ from Dieter?

On the application I was building, I had a requirement to deploy as a JAR; Dieter expects all the assets to be on the filesystem; I spent some time attempting to hack the Dieter code to allow resources on the classpath as well.
When that proved unsuccessful, I decided to build out something a bit more ambitious, that would support the features that have accumulated in Tapestry over the last few years.

Twixt also embraces http://www.infoq.com/presentations/Clojure-Large-scale-patterns-techniques[system as transient state], meaning nothing is stored statically.

Twixt will grow further apart from Dieter as the more advanced pieces are put into place.
