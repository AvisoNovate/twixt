== Twixt

Twixt is an extensible asset pipeline for use in Clojure web applications.
It is designed to complement an application built using Ring and related libraries, such as Compojure.
Twixt provides content transformation (such as Less to CSS), support for efficient immutable resources,
and best-of-breed exception reporting.

Twixt includes a very readable HTML exception report page, which displays:

* The entire stack of nested exceptions, top to bottom
* The stack trace for only the root exception
* Demangled namespace and function names for Clojure stack frames: `io.aviso.twixt/new-twixt/reify/middleware/fn` instead of
  `io.aviso.twixt$new_twixt$reify__954$middleware__959$fn__960.invoke()`.
* The contents of the Ring request map
* All JVM system properties

Twixt draws inspiration from http://tapestry.apache.org[Apache Tapestry] and https://github.com/edgecase/dieter[Dieter].

Twixt currently supports:

* CoffeeScript to JavaScript compilation (using Rhino)
* Jade to HTML compilation (using https://github.com/neuland/jade4j[jade4j])
* Less to CSS compilation (using https://github.com/SomMeri/less4j[less4j])
* File system caching of compiled content
* Automatic GZip compression

Twixt is available under the terms of the Apache Sofware License 2.0.

Twixt is downloadable from the https://clojars.org/io.aviso/twixt[Clojars Repository].

http://howardlewisship.com/io.aviso/twixt/[API Documentation]

=== Usage

By default, Twixt serves resources located on the classpath, in the +META-INF/assets/+ folder.
The contents of this folder is accessible via the URL +/assets/+.

By design, assets are segregated from the rest of your code.
This prevents a malicious client from directly accessing your code or configuration files.
Anything outside the +META-INF/assets/+ folder is inaccessible via Twixt.

Twixt maps file extensions to MIME types; it then will transform certain MIME types; for example +.coffee+ files are compiled to JavaScript.

[source,clojure]
----
(ns example.app
  (:use compojure.core
        ring.adapter.jetty
        [io.aviso.twixt :as t]
        [io.aviso.twixt.exceptions :as te))

;;; Use Compojure to map routes to handlers
(defroutes app ...)

;;; Create twixt wrappers and handler to handle /asset/ URLs, in development (not production) mode
(def app-handler
  (te/wrap-with-twixt app true)

;;; Use the Ring Jetty adapter to serve your site
(run-jetty app-handler)
----  

The Twixt middleware intercepts requests for +/assets/+ that map to actual files; non-matching requests, or
requests for assets that do not exist, are delegated down to the wrapped handlers.

In development mode, Twixt will write compiled files to the file system (you can configure where if you like). 
On a restart of the application, it will use those cached files if the source files have not changed.

The Twixt API includes alternate way of constructing both the Ring middleware, and Twixt's own
asset pipeline; this allows you to add new features, or eliminate unwanted features. Please reference the
code to see how to assemble Twixt options, the Twixt pipeline, and finally, how to provide the necessary
Ring middleware.

=== A question of URLs

At its core, Twixt is a set of Ring middleware that maps certain URL patterns to matching files on the classpath,
and does some transformations along the way.

Currently, the mapping is very straightforward: the path +/assets/123abc/css/style.less+ is mapped to resource
+META-INF/assets/css/style.less+ and transformed from Less to CSS along the way.
Embedded in in the middle is the content checksum for the file (+123abc+).

In your application, assets will change during development, or between production deployments. The URIs provided to
the client agent (the web browser) is a _resource_; resources are immutable.
The checksum in the URI is based on the actual content of the file;
if the underlying content changes, then a new checksum, new URI, and therefore, new resource will be referenced.

Twixt sets headers to indicate a far-future expiration date for the resource;
the upshot of which is that, once the resource for an asset is downloaded to the client browser, the browser will not ask for it again.
This is great for performance.

The checksum has a optional "z" prefix; this indicates a GZip compressed resource.
Twixt detects if the client agent supports GZip compression (via the +Accept-Encodings+ header).
In addition, compression is only applied to specific content types, such as "text/html" and "application/edn".
Most binary formats, including fonts and image formats, are already compressed.

Because of this, when referencing assets inside your templates, you must pass paths (relative to +META-INF/assets+)
through Twixt to get URIs that will work in the browser:

[source,clojure]
----
(defhtml index
  [context]
  (html
    (doctype :html5
    [:html
      [:head
        [:title "My Clojure App"]
        (include-css (get-asset-uri context "css/style.less"))
        ...
----

The context parameter is a map that is provided in the Ring request map under key +:twixt+.

Twixt must do all necessary compilations and other transformations, to arrive at final content for which a checksum
can be generated. This is also good because any exceptions, such as compilation errors, will occur immediately, rather
than when the asset's resource is accessed by the client.

When a client requests an asset that exists, but supplies an incorrect checksum,
Twixt will respond with a 301 HTTP response,
directing the client to the correct resource (with the correct checksum).

=== Configuring Twixt

Twixt's configuration is used to determine where to locate asset resources on the classpath, 
and what folder to serve them under. It also maps file name extensions to MIME types, and
configures the file system cache.

The default options:

[source,clojure]
----
(def default-options
  {:path-prefix        "/assets/"
   :root               "META-INF/assets/"
   :content-types      (merge mime/default-mime-types {"coffee" "text/coffeescript"
                                                       "less"   "text/less"
                                                       "jade"   "text/jade"})
   :compressable       #{"text/*" "application/edn" "application/json"}
   :cache-folder       (System/getProperty "twixt.cache-dir" (System/getProperty "java.io.tmpdir"))
----

You can override +root+ to change where assets are stored on the classpath, but there is rarely a need to do so.
Changing root may break other libraries that depend on Twixt, such as Twixt's own exception reporting.

You can override +:path-prefix+ to change the root URL for assets; +/+ is an acceptable value.

The +:content-types+ key maps file extensions to MIME types.

The +:compressable+ key identifies which content types are compressable; note the use of the +/*+ suffix to indicate
that all text content types are compressable.

File system caching is normally only enabled in development mode.

Twixt always caches the content of files in memory, after any transforming operations (such as compiling CoffeeScript to
JavaScript). 
In development mode, checks are enabled to refresh the cache when underlying files are modified; 
in production, no such checks occur as it is assumed that all such assets are stable
(until the entire application is re-deployed).

=== Future Plans

The goal is to achieve at least parity with Apache Tapestry, plus some additional features specific to Clojure. This means:

* E-Tags support
* ClojureScript compilation
* JavaScript minimization via https://developers.google.com/closure/compiler/[Google Closure]
* CSS Minification
* Aggregated JavaScript stacks
* Aggregated CSS stacks
* RequireJS support / modules
* Leverage core.async ?
* Break out the the Lesâ€¢s, Jade, CoffeeScript, and exception reporting support into a-la-carte modules

=== Stability

*Alpha*: Most features are not yet implemented and the code is likely to change in many ways going forward ... but still very
useful!

=== A note about feedback

http://tapestryjava.blogspot.com/2013/05/once-more-feedback-please.html[Feedback] is very important to me; I often find
Clojure just a bit frustrating, because if there is an error in your code, it can be a bit of a challenge to track the problem
backwards from the failure to the offending code. Part of this is inherent in functional programming, part of it is related to lazy evaluation,
and part is the trade-off between a typed and untyped language.

In any case, it is very important to me that when thing go wrong, you are provided with a detailed description of the failure.
Twixt has a mechanism for tracking the operations it is attempting, to give you insight into what exactly failed if there
is an error.  For example, (from the test suite):

----
ERROR [       qtp2166970-29] io.aviso.twixt.coffee-script An exception has occurred:
ERROR [       qtp2166970-29] io.aviso.twixt.coffee-script [  1] - Invoking handler (that throws exceptions)
ERROR [       qtp2166970-29] io.aviso.twixt.coffee-script [  2] - Accessing asset `invalid-coffeescript.coffee'
ERROR [       qtp2166970-29] io.aviso.twixt.coffee-script [  3] - Compiling `META-INF/assets/invalid-coffeescript.coffee' to JavaScript
ERROR [       qtp2166970-29] io.aviso.twixt.coffee-script META-INF/assets/invalid-coffeescript.coffee:6:1: error: unexpected INDENT
      argument: dep2
^^^^^^
java.lang.RuntimeException: META-INF/assets/invalid-coffeescript.coffee:6:1: error: unexpected INDENT
      argument: dep2
^^^^^^
   ....
----

In other words, when there's a failure, Twixt can tell you the steps that led up the failure, which is 90% of solving the problem in the first place.

Twixt's exception report captures all of this and presents it as readable HTML.
The exception report page also does a decent job of de-mangling Java class names to Clojure namespaces and function names.

=== How does Twixt differ from Dieter?

On the application I was building, I had a requirement to deploy as a JAR; Dieter expects all the assets to be on the filesystem; I spent some time attempting to hack the Dieter code to allow resources on the classpath as well.
When that proved unsuccessful, I decided to build out something a bit more ambitious, that would support the features that have accumulated in Tapestry over the last few years.

Twixt also embraces http://www.infoq.com/presentations/Clojure-Large-scale-patterns-techniques[system as transient state], meaning nothing is stored statically.

Twixt will grow further apart from Dieter as the more advanced pieces are put into place.
